<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/scenes/GameScene.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/scenes/GameScene.js" />
              <option name="originalContent" value="export default class GameScene extends Phaser.Scene {&#10;    constructor() {&#10;        super('GameScene');&#10;        this.player = null;&#10;        this.opponent = null;&#10;        this.ball = null;&#10;        this.cursors = null;&#10;        this.ballCooldown = false;&#10;        this.leftBorder = null;&#10;        this.rightBorder = null;&#10;&#10;        // Music rotation system&#10;        this.musicTracks = [&#10;            'assets/music/chipsounds.mod',&#10;            'assets/music/cydonian sky.xm',&#10;            'assets/music/mysteristerium.mod',&#10;            'assets/music/rfchip001.xm'&#10;        ];&#10;        this.currentMusicIndex = 0;&#10;    }&#10;&#10;    create() {&#10;        // Create paddles&#10;        this.player = this.add.rectangle(this.cameras.main.width / 2, this.cameras.main.height - 50, 100, 20, 0xffffff);&#10;        this.physics.add.existing(this.player);&#10;        this.player.body.setCollideWorldBounds(true);&#10;        this.player.body.setImmovable(true);&#10;&#10;        this.opponent = this.add.rectangle(this.cameras.main.width / 2, 50, 100, 20, 0xffffff);&#10;        this.physics.add.existing(this.opponent);&#10;        this.opponent.body.setCollideWorldBounds(true);&#10;        this.opponent.body.setImmovable(true);&#10;&#10;        // Create ball using the new function&#10;        this.createBall();&#10;&#10;        // Input&#10;        this.cursors = this.input.keyboard.createCursorKeys();&#10;&#10;        // Draw borders&#10;        const borderWidth = 10;&#10;        const screenWidth = this.cameras.main.width;&#10;        const screenHeight = this.cameras.main.height;&#10;&#10;        // Top border (visual only, ball should pass through for scoring)&#10;        this.add.rectangle(screenWidth / 2, borderWidth / 2, screenWidth, borderWidth, 0xffffff);&#10;        // Bottom border (visual only, ball should pass through for scoring)&#10;        this.add.rectangle(screenWidth / 2, screenHeight - borderWidth / 2, screenWidth, borderWidth, 0xffffff);&#10;&#10;        // Left border (make it a physics body)&#10;        this.leftBorder = this.add.rectangle(borderWidth / 2, screenHeight / 2, borderWidth, screenHeight, 0xffffff);&#10;        this.physics.add.existing(this.leftBorder, true); // true for static body&#10;&#10;        // Right border (make it a physics body)&#10;        this.rightBorder = this.add.rectangle(screenWidth - borderWidth / 2, screenHeight / 2, borderWidth, screenHeight, 0xffffff);&#10;        this.physics.add.existing(this.rightBorder, true); // true for static body&#10;&#10;        this.playNextSong();&#10;    }&#10;&#10;    createBall() {&#10;        // Create ball&#10;        this.ball = this.add.rectangle(this.cameras.main.width / 2, this.cameras.main.height / 2, 20, 20, 0xffffff);&#10;        this.physics.add.existing(this.ball);&#10;        this.ball.body.setBounce(1, 1);&#10;        this.ball.body.setVelocity(200, 200);&#10;&#10;        // Physics interactions&#10;        this.physics.add.collider(this.ball, this.player, this.hitPaddle, null, this);&#10;        this.physics.add.collider(this.ball, this.opponent, this.hitPaddle, null, this);&#10;&#10;        // Add colliders for ball with left and right borders (if they exist)&#10;        if (this.leftBorder) {&#10;            this.physics.add.collider(this.ball, this.leftBorder);&#10;        }&#10;        if (this.rightBorder) {&#10;            this.physics.add.collider(this.ball, this.rightBorder);&#10;        }&#10;    }&#10;&#10;    update() {&#10;        // Player movement&#10;        if (this.cursors.left.isDown) {&#10;            this.player.body.setVelocityX(-300);&#10;        } else if (this.cursors.right.isDown) {&#10;            this.player.body.setVelocityX(300);&#10;        } else {&#10;            this.player.body.setVelocityX(0);&#10;        }&#10;&#10;        // AI movement&#10;        this.updateOpponent();&#10;&#10;        // Score update - only check if ball exists&#10;        if (this.ball &amp;&amp; this.ball.active) {&#10;            if (this.ball.y &gt; this.cameras.main.height) {&#10;                this.events.emit('opponentScore');&#10;                this.handleScore();&#10;            } else if (this.ball.y &lt; 0) {&#10;                this.events.emit('playerScore');&#10;                this.handleScore();&#10;            }&#10;        }&#10;    }&#10;&#10;    handleScore() {&#10;        // Delete the ball&#10;        this.ball.destroy();&#10;&#10;        window.pauseChiptune();&#10;&#10;        this.sound.play('gameover');&#10;        const gameoverSound = this.sound.get('gameover')&#10;&#10;        // Pause the music&#10;        // Wait for the gameover sound to finish before recreating the ball&#10;        gameoverSound.on('complete', () =&gt; {&#10;            this.createBall();&#10;            this.playNextSong();&#10;        });&#10;    }&#10;&#10;    playNextSong() {&#10;        // Rotate to next song&#10;        this.currentMusicIndex = (this.currentMusicIndex + 1) % this.musicTracks.length;&#10;        const nextTrack = this.musicTracks[this.currentMusicIndex];&#10;        window.playChiptune(nextTrack);&#10;    }&#10;&#10;    updateOpponent() {&#10;        // Only update opponent AI if ball exists&#10;        if (!this.ball || !this.ball.active) {&#10;            this.opponent.body.setVelocityX(0);&#10;            return;&#10;        }&#10;&#10;        const ballX = this.ball.x;&#10;        const opponentX = this.opponent.x;&#10;        const diff = ballX - opponentX;&#10;&#10;        if (Math.abs(diff) &lt; 10) {&#10;            return;&#10;        }&#10;&#10;        const speed = 200;&#10;        if (diff &gt; 0) {&#10;            this.opponent.body.setVelocityX(speed);&#10;        } else {&#10;            this.opponent.body.setVelocityX(-speed);&#10;        }&#10;    }&#10;&#10;    resetBall() {&#10;        this.ball.setPosition(this.cameras.main.width / 2, this.cameras.main.height / 2);&#10;        this.ball.body.setVelocity(200, 200);&#10;    }&#10;&#10;    hitPaddle(ball, paddle) {&#10;        if (this.ballCooldown) {&#10;            return;&#10;        }&#10;        this.ballCooldown = true;&#10;&#10;        // bring back the ball position to last value&#10;        this.sound.play('blip');&#10;        ball.body.velocity.y *= -1;&#10;        ball.body.velocity.x += Phaser.Math.Between(-20, 20);&#10;&#10;        this.time.delayedCall(100, () =&gt; {&#10;            this.ballCooldown = false;&#10;        });&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="export default class GameScene extends Phaser.Scene {&#10;    constructor() {&#10;        super('GameScene');&#10;        this.player = null;&#10;        this.opponent = null;&#10;        this.ball = null;&#10;        this.cursors = null;&#10;        this.ballCooldown = false;&#10;        this.leftBorder = null;&#10;        this.rightBorder = null;&#10;&#10;        // Music rotation system&#10;        this.musicTracks = [&#10;            'assets/music/chipsounds.mod',&#10;            'assets/music/cydonian sky.xm',&#10;            'assets/music/mysteristerium.mod',&#10;            'assets/music/rfchip001.xm'&#10;        ];&#10;        this.currentMusicIndex = 0;&#10;    }&#10;&#10;    create() {&#10;        // Create paddles&#10;        this.player = this.add.rectangle(this.cameras.main.width / 2, this.cameras.main.height - 50, 100, 20, 0xffffff);&#10;        this.physics.add.existing(this.player);&#10;        this.player.body.setCollideWorldBounds(true);&#10;        this.player.body.setImmovable(true);&#10;&#10;        this.opponent = this.add.rectangle(this.cameras.main.width / 2, 50, 100, 20, 0xffffff);&#10;        this.physics.add.existing(this.opponent);&#10;        this.opponent.body.setCollideWorldBounds(true);&#10;        this.opponent.body.setImmovable(true);&#10;&#10;        // Create ball using the new function&#10;        this.createBall();&#10;&#10;        // Input&#10;        this.cursors = this.input.keyboard.createCursorKeys();&#10;&#10;        // Draw borders&#10;        const borderWidth = 10;&#10;        const screenWidth = this.cameras.main.width;&#10;        const screenHeight = this.cameras.main.height;&#10;&#10;        // Top border (visual only, ball should pass through for scoring)&#10;        this.add.rectangle(screenWidth / 2, borderWidth / 2, screenWidth, borderWidth, 0xffffff);&#10;        // Bottom border (visual only, ball should pass through for scoring)&#10;        this.add.rectangle(screenWidth / 2, screenHeight - borderWidth / 2, screenWidth, borderWidth, 0xffffff);&#10;&#10;        // Left border (make it a physics body)&#10;        this.leftBorder = this.add.rectangle(borderWidth / 2, screenHeight / 2, borderWidth, screenHeight, 0xffffff);&#10;        this.physics.add.existing(this.leftBorder, true); // true for static body&#10;&#10;        // Right border (make it a physics body)&#10;        this.rightBorder = this.add.rectangle(screenWidth - borderWidth / 2, screenHeight / 2, borderWidth, screenHeight, 0xffffff);&#10;        this.physics.add.existing(this.rightBorder, true); // true for static body&#10;&#10;        this.playNextSong();&#10;    }&#10;&#10;    createBall() {&#10;        // Create ball&#10;        this.ball = this.add.rectangle(this.cameras.main.width / 2, this.cameras.main.height / 2, 20, 20, 0xffffff);&#10;        this.physics.add.existing(this.ball);&#10;        this.ball.body.setBounce(1, 1);&#10;        this.ball.body.setVelocity(200, 200);&#10;&#10;        // Physics interactions&#10;        this.physics.add.collider(this.ball, this.player, this.hitPaddle, null, this);&#10;        this.physics.add.collider(this.ball, this.opponent, this.hitPaddle, null, this);&#10;&#10;        // Add colliders for ball with left and right borders (if they exist)&#10;        if (this.leftBorder) {&#10;            this.physics.add.collider(this.ball, this.leftBorder);&#10;        }&#10;        if (this.rightBorder) {&#10;            this.physics.add.collider(this.ball, this.rightBorder);&#10;        }&#10;    }&#10;&#10;    update() {&#10;        // Player movement - use mouse/touch position&#10;        const pointer = this.input.activePointer;&#10;        const mouseX = pointer.x;&#10;        const paddleX = this.player.x;&#10;        &#10;        // Move paddle based on mouse position relative to paddle&#10;        if (mouseX &lt; paddleX - 10) {&#10;            this.player.body.setVelocityX(-300);&#10;        } else if (mouseX &gt; paddleX + 10) {&#10;            this.player.body.setVelocityX(300);&#10;        } else {&#10;            this.player.body.setVelocityX(0);&#10;        }&#10;&#10;        // AI movement&#10;        this.updateOpponent();&#10;&#10;        // Score update - only check if ball exists&#10;        if (this.ball &amp;&amp; this.ball.active) {&#10;            if (this.ball.y &gt; this.cameras.main.height) {&#10;                this.events.emit('opponentScore');&#10;                this.handleScore();&#10;            } else if (this.ball.y &lt; 0) {&#10;                this.events.emit('playerScore');&#10;                this.handleScore();&#10;            }&#10;        }&#10;    }&#10;&#10;    handleScore() {&#10;        // Delete the ball&#10;        this.ball.destroy();&#10;&#10;        window.pauseChiptune();&#10;&#10;        this.sound.play('gameover');&#10;        const gameoverSound = this.sound.get('gameover')&#10;&#10;        // Pause the music&#10;        // Wait for the gameover sound to finish before recreating the ball&#10;        gameoverSound.on('complete', () =&gt; {&#10;            this.createBall();&#10;            this.playNextSong();&#10;        });&#10;    }&#10;&#10;    playNextSong() {&#10;        // Rotate to next song&#10;        this.currentMusicIndex = (this.currentMusicIndex + 1) % this.musicTracks.length;&#10;        const nextTrack = this.musicTracks[this.currentMusicIndex];&#10;        window.playChiptune(nextTrack);&#10;    }&#10;&#10;    updateOpponent() {&#10;        // Only update opponent AI if ball exists&#10;        if (!this.ball || !this.ball.active) {&#10;            this.opponent.body.setVelocityX(0);&#10;            return;&#10;        }&#10;&#10;        const ballX = this.ball.x;&#10;        const opponentX = this.opponent.x;&#10;        const diff = ballX - opponentX;&#10;&#10;        if (Math.abs(diff) &lt; 10) {&#10;            return;&#10;        }&#10;&#10;        const speed = 200;&#10;        if (diff &gt; 0) {&#10;            this.opponent.body.setVelocityX(speed);&#10;        } else {&#10;            this.opponent.body.setVelocityX(-speed);&#10;        }&#10;    }&#10;&#10;    resetBall() {&#10;        this.ball.setPosition(this.cameras.main.width / 2, this.cameras.main.height / 2);&#10;        this.ball.body.setVelocity(200, 200);&#10;    }&#10;&#10;    hitPaddle(ball, paddle) {&#10;        if (this.ballCooldown) {&#10;            return;&#10;        }&#10;        this.ballCooldown = true;&#10;&#10;        // bring back the ball position to last value&#10;        this.sound.play('blip');&#10;        ball.body.velocity.y *= -1;&#10;        ball.body.velocity.x += Phaser.Math.Between(-20, 20);&#10;&#10;        this.time.delayedCall(100, () =&gt; {&#10;            this.ballCooldown = false;&#10;        });&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>